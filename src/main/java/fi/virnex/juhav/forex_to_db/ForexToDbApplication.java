package fi.virnex.juhav.forex_to_db;

import org.springframework.beans.factory.annotation.Autowired;

//import org.quartz.*;
//import org.quartz.impl.StdSchedulerFactory;
//import static org.quartz.JobBuilder.newJob;
//import static org.quartz.TriggerBuilder.newTrigger;

import org.springframework.beans.factory.annotation.Autowired;

import org.springframework.boot.CommandLineRunner;
import org.springframework.boot.SpringApplication;
import org.springframework.boot.autoconfigure.AutoConfiguration;
import org.springframework.boot.autoconfigure.SpringBootApplication;
import org.springframework.context.annotation.ComponentScan;
import org.springframework.core.annotation.Order;
import org.springframework.stereotype.Component;

import fi.virnex.juhav.forex_to_db.model.ForexRate;
import fi.virnex.juhav.forex_to_db.non_web_service.NonWebService;
import fi.virnex.juhav.forex_to_db.repository.IForexRepository;

import java.text.SimpleDateFormat;
import java.time.Duration;
import java.time.LocalDateTime;
import java.time.LocalTime;
import java.util.Calendar;
import java.util.Date;

// This forex_to_db java/Spring Boot project collects periodically (now fixed hourly)
// currency exchange rate data from an external API under apilayer.com.
// The data is stored as rows in forex_data named table in a persistent postgreSQL database (DB)
// that runs in a docker container forex_db. For persistent storage a docker volume
// named forex_vol is created if it does not already exist and updated if it already exists.
// This application runs also in another docker container named forex_to_db.
// The docker related files are stored under src/main/docker folder.
// The application is started from terminal by a single command:
// apikey=xxx run_max_hours=z docker-compose up
// Replace xxx with a valid apikey for a apilayer.com currency exchange data account.
// Or replace xxx with DUMMY to show periodically (now hourly) only 3 fabricated fake rows
// that will be inserted into an empty forex_data table in the DB.
// Replace z with a value from range [-1, 0, 1, 2, 3, ...].
// Replace z with value -1 to run the queries once immediately and to repeat the same
// queries forever at each full hour [00:00, 01:00, 02:00, ... , 23:00].
// Replace z with value 0 to run the queries only once immediately - no repetition.
// Replace z with value 1 to run the queries once immediately and repeat once at the next
// full hour.
// ...
// Replace z with 7 for to run the queries once immediately and to repeat the queries
// on next 7 full hours.
// ...
// The first data collection is always run immediately independent of start time.
// The following data collections are run at each full hour at hh:00:00 (time hh:mm:ss).
//
// In Eclipse the java jar package is generated by selecting the forex_to_db project
// from Project Explorer and then right-click > Run As > Maven Install. 
// This way forex_to_db/target/forex_to_db.jar gets generated.
// The clean_docker.sh Linux bash script under src/main/docker is used to delete old
// docker related stuff and to copy forex_to_db/target/forex_to_db.jar to
// forex_to_db/src/main/docker folder. The docker-compose.yml file is in the same
// forex_to_db/src/main/docker folder. Docker-compose.yml is used to run everything
// from generating the images, creating&starting the 2 containers forex_db (posgreSQL DB) and
// forex_to_db container which runs this application.
//
// To generalise this forex exchange rate data collection application further following
// 3 steps are seen as simple and clear:
// -store the set of currencies covered [USD,EUR,SEK,NOK,...] in an environment variable at startup or in an environment variable file like application.properties.
// -turn the interval between collections from fixed 1h into environment variable as well.
// -a simple python script (e.g. streamlit) could show the currency exchange rates from the docker DB
// as graphs/charts/plots where x-axis is the date_time and y-axis is the currency exchange rate.

// Note: I add "too much" comments so that the code and the logic would be easy
// to understand for an complete outsider or a student. There is no
// need to read the comments unless the logic of the code seems unclear.

@AutoConfiguration
@SpringBootApplication
@ComponentScan(basePackages = {"fi.virnex.juhav.forex_to_db"})
public class ForexToDbApplication implements CommandLineRunner {
    
	// This is only a demo application.
	// A dummy or invalid apikey may be used to run the application using predefined fake or old data in the database.
	// To limit unnecessary load to the apilayer.com forex exchange data web site, 
	// this demo will terminate at latest after the number of failed queries reaches below limit.
	public static final long  TOTAL_FAILED_QUERIES_LIMIT_TO_STOP_APPLICATION = 3;

	// apikey is an id token String required by the external apilayer.com forex exchange rate.
	// We cannot get forex data from the API without a valid apikey.
	// This application can anyway be run with an invalid or dummy apikey.
	// In that case only fabricated fake or old data will be shown from our docker postgreSQL database.
	// apikey is set from terminal within the docker-compose up command.
	private static String apikey = System.getenv("apikey");
	
	// runMaxHours is initialised from an optional environment variable run_max_hours.
	// The optional environment variable run_max_hours can be set from terminal within the docker-compose up command.
	// If the environment variable is undefined, a default value = "1" will be set later.
	// E.g. value "3" means run collection immediately once and repeat the collection 3 times at next full hours.
	// The value "1" means run collection immediately once AND repeat collection once at next full hour.
	// The value "0" means run collection once immediately but do not repeat the collection.
	// The value "-1" means run the collection once immediately and repeat every hour forever.
	
	private static String runMaxHours = System.getenv("run_max_hours");	// will be set to "1" if undefined.
	private static long runMaxHoursCount = 1;	// will be set to the long value of runMaxHours, default 1.
        
    @Autowired
    NonWebService nonWebService;
	
    public static void main(String[] args) {
       SpringApplication application = new SpringApplication(ForexToDbApplication.class);
        
        // ... customize application settings here
        
       application.run();
    }

    @Override
    public void run(String... args) throws Exception {	// to be called hourly from Linux crontab for Siili/Free.fi task
    	
    	System.out.println("ForexToDbApplication.run(String... args) checks that apikey for apilayer forex API is available:");
 
    	// Check that a non-empty apikey is available as environment variable.
    	// Mandatory to have some valid or invalid value to run demo.
    	// It is set within the application starting command docker-compose up from terminal.
    	// It will be used by non_web_service.NonWebService.
    	String apikey = System.getenv("apikey");
    	
    	if ( (apikey == null) || (apikey.length()< 1) ) {
    		System.out.println("Terminating due to lack value for apikey environment variable.");
    		System.out.println();
    		printHintsToRunThisApplication();
    		System.exit(1);
    	}
    	
		// !!! !!! !!! avoid exceeding daily/monthly limit of free queries to forex API during development !!! !!! !!!
		// apikey = "DUMMY";		// invalid key, query not counted by apilayer forex rate data web site !!! !!! !!!
    	
    	// Check if optional environment variable run_max_hours is available.
    	// It can be set within the application starting command docker-compose up from terminal.
    	// The value or a default value will be used by non_web_service.NonWebService.
    	// default value "1" will be used if the value is undefined.
    	String runMaxHours = System.getenv("run_max_hours");
    	
    	// by default run queries once immediately
    	// and repeat just once at the next full hour.  
    	long runMaxHoursCount = 1;

    	if ( (runMaxHours != null) && (runMaxHours.length() > 0)) {
    		try {
    			runMaxHoursCount = Long.parseLong(runMaxHours);
    		} catch (Exception e){
    			System.out.println("ForexToDbApplication.run()failed parsing environment variable run_max_hours=" + runMaxHours);
    			System.out.println("Exception " + e + " in ForexToDbApplication.run()");
    			System.out.println("Run is continued with default value environment variable run_max_hours=1");
    			System.out.println("run_max_hours=1 means run forex queries once immediately and repeat once at the next full hour.");
    			System.out.println("If you are happy with the default, you can skip reading following guidance:");
    			System.out.println("-------IF-------");
    			System.out.println("If you want to set run_max_hours to other value than 1:");
    			System.out.println("Interrupt from your terminal by ctrl-c");
    			System.out.println("Then give following command from your terminal:");
    			System.out.println("docker-compose down");
    			System.out.println("-------IF-------");
    			System.out.println("For a rerun with your values, please follow following steps:");
    			printHintsToRunThisApplication();
    			runMaxHoursCount = 1;
    		}
    	}
    	
    	System.out.println("Using apikey value: " + apikey);	// !!! only in development version !!!
    	
    	nonWebService.collectAndSaveForexDataEveryHour(apikey, runMaxHoursCount, TOTAL_FAILED_QUERIES_LIMIT_TO_STOP_APPLICATION);
    }
    
    private void printHintsToRunThisApplication() {
    	System.out.println("Please, use following command to start forex_to_db (ForexToDbApplication) java Spring Boot Application:");
		System.out.println("apikey=xxx run_max_hours=z docker-compose up");
		System.out.println("Replace xxx with your valid apikey for apilayer.com forex rate data web site.");
		System.out.println("Replace z by -1 to run forever"); 
		System.out.println("or replace z by a whole number like 0 or 1 or 2 ... to define the max number of hourly repetitions.");
		System.out.println("-------");
		System.out.println("For any special case, please continue reading.");
		System.out.println("-------");
		System.out.println("Test run without valid apikey:");
		System.out.println("apikey=xxx run_max_hours=z docker-compose up");
		System.out.println("An example for a test run:");
		System.out.println("apikey=test run_max_hours=1 docker-compose up");
		System.out.println("For just a test run without valid apikey replace xxx with DUMMY.");
    	System.out.println("The test with invalid apikey will show only fake and possibly already collected real but old forex data from the database.");
     	System.out.println("Such a test is anyway NOT recommended to avoid unnecessary load for the apilayer.com forex data API web site.");
     	System.out.println("-------");
     	System.out.println("Replace z by 0 to run the forex rate queries immediately just once without repetition.");
     	System.out.println("This demo application is also terminated after totally " + TOTAL_FAILED_QUERIES_LIMIT_TO_STOP_APPLICATION + " failed queries." );
     	System.out.println("The restart of docker container forex_to_db is disabled to protect apilayer.com forex data web site from unnecessary queries.");
     	System.out.println("The restart of docker container forex_db is set to unless-stopped.");
     	System.out.println("The docker-compose.yml file is under src/main/docker folder.");
    }
    
}

/////////////////////////////////////////////////////////////////////////////////////////////////////////
/*
 *  // Below parts kept as a historical monument from attempts to use Quartz Scheduler.
 *  // The quartz scheduler lead to hanging jobs/method calls that never returned from trying to contact the API web site.
 *  // The System.out.println("...") lines before and after the method call got executed even the 
 *  // method call contacting the external API never returned?!?!?
 *  // Others have had similar problems based on web search without solution there, e.g. quartz with a database.
 *  // The problem seems to be hiding somewhere inside the quartz or in related dependencies.
 *  // There is no error indication from java/quartz nor from any dependency.
 *  // I decided to make a simple and clear solution instead of forcing the use of quartz.
 *  // Also use of quartz would require lots of extra lines of code for the simple case in the task.
 *  // The code is not a complete example of what I had as I gave up during a modification attempt.   
public class ... {

    public static void main(String[] args) {
        QuartzJobParamExample quartzJobParamExample = new QuartzJobParamExample();
        quartzJobParamExample.initForexDbWithDummyData();
        // quartzJobParamExample.fetchAndSaveForexData();
    }
    
    private static final Properties applicationProperties = getApplicationProperties();

	private static final Properties getApplicationProperties() {
	  Properties properties = new Properties();
	  try {
		  InputStream input = ExampleJob.class.getClassLoader().getResourceAsStream("application.properties");
		  properties.load(input);
		  input.close();
	  } catch (Exception e) {
		  System.out.println("ExampleJob.getApplicationProperties() failed loading file application.properties: " + e);		  
	  }
	  return properties;
	}
	
	@Autowired
    private IForexRepository repository;
	
    private void fetchAndSaveForexData() {
    	
    	// String apikey = applicationProperties.getProperty("forex_api.apikey");
		String apikey = System.getenv("apikey");
		
		// apikey = "DUMMY";		// !!! !!! !!!
		
		System.out.println("apikey: " + apikey);
		
		ForexRequestDTO forexRequestDTO = new ForexRequestDTO();
		forexRequestDTO.setFromAmount(1);
		forexRequestDTO.setFromCurrency("EUR");
		forexRequestDTO.setToCurrency("USD");
		
		System.out.println(forexRequestDTO.toString());
		
		try {
			// System.out.println("before fetch");
			Optional<Object> response = ForexDAO.fetch(forexRequestDTO, apikey);
			// System.out.println("after fetch");
			if (response.isPresent()) {
				if ( ((Object) response.get()).getClass() == org.javacodegeeks.ForexResponseDTO.class ) {
				   ForexResponseDTO forexResponseDTO = (ForexResponseDTO) response.get();
				   
				   ForexRate forexRateBeforeSave = new ForexRate();
				   
				   forexRateBeforeSave.setRateDate( forexResponseDTO.getRateDate() );
				   forexRateBeforeSave.setFromCurrency( forexResponseDTO.getFromCurrency() );
				   forexRateBeforeSave.setToCurrency( forexResponseDTO.getToCurrency() );
				   forexRateBeforeSave.setExchangeRate(forexResponseDTO.getExchangeRate() );
				   
				   ForexRate forexRateAfterSave = repository.save(forexRateBeforeSave);
				   
				   System.out.println(forexRateAfterSave.toJsonStringWithId());
				} else {
					System.out.println("Error: " + response.toString());
				}
			} else {
				System.out.println("Error: " + response.toString());
			}
		} catch (Exception e1) {
			System.out.println("Exception " + e1 + " in ExampleJob during ForexDAO.fetch()");
		}

    }
    
    // An empty table in DB is assumed.
    // Add 3 dummy data rows to avoid exceeding the daily/monthly free limit of forex data API queries.
    // If the table is not empty, duplicate rows with different id column may get created.
    private void initForexDbWithDummyData() {
    	String[] rateDates  = { "2022-01-01", "2022-01-03", "2022-01-07" };
    	String fromCurrency = "EUR";
    	String toCurrency = "NOK";
    	double[] rates = { 10.1, 10.3, 10.7 };
    	
    	for (int i= 0; i < 3 ; i++) {
    		ForexRate forexRateBeforeSave = new ForexRate();
    		
    		forexRateBeforeSave.setRateDate( rateDates[i] );
    		forexRateBeforeSave.setFromCurrency( fromCurrency );
    		forexRateBeforeSave.setToCurrency( toCurrency );
    		forexRateBeforeSave.setExchangeRate( rates[i] );
    		
    		// at save DB generates the id and save returns the row object with the id.
    		ForexRate forexRateAfterSave = repository.save( forexRateBeforeSave );
    		System.out.println("Added dummy row to DB: " + forexRateAfterSave.toJsonStringWithId() );
    	}
   }

    private void run() {

        // First we must get a reference to a scheduler
        SchedulerFactory schedulerFactory = new StdSchedulerFactory();
        try {
            Scheduler scheduler = schedulerFactory.getScheduler();

            // define the job and tie it to our HelloJob class
            JobDetail job = newJob(ExampleJob.class).withIdentity("MyJobName", "MyJobGroup").build();
            job.getJobDataMap().put("PARAM_1_NAME", "PARAM_1_VALUE");
            job.getJobDataMap().put("PARAM_2_NAME", "PARAM_2_VALUE");
            job.getJobDataMap().put("PARAM_3_NAME", "PARAM_3_VALUE");
            job.getJobDataMap().put("apikey", System.getenv("apikey") );

            // Trigger the job to run after 3 seconds
            Date date = Date.from(LocalDateTime.now().plusSeconds(3).atZone(ZoneId.systemDefault()).toInstant());
            Trigger trigger = newTrigger().withIdentity("MyTriggerName", "MyTriggerGroup").startAt(date).build();

            // Tell quartz to schedule the job using our trigger
            scheduler.scheduleJob(job, trigger);
            System.out.println(job.getKey() + " will run at: " + date);

            // Start up the scheduler (nothing can actually run until the scheduler has been started)
            scheduler.start();

            // wait long enough so that the scheduler as an opportunity to run the job!
            System.out.println("Waiting for 17 seconds");
            try {
                // wait 17 seconds to show job
                Thread.sleep(17*1000);
            } catch (Exception e) {
            	System.out.println("woke up from 17s sleep");
            }

            // Shutdown the scheduler
            System.out.println("shutting down scheduler");
            scheduler.shutdown(true);
            System.out.println("shutted down scheduler");

        } catch (SchedulerException e) {
            e.printStackTrace();
        }
    }
    */
